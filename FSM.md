### Понимание FSM (Finite State Machine) в вашем Телеграм-боте

**Finite State Machine (FSM)**, или конечный автомат, — это модель вычислений, используемая для управления состояниями и переходами между ними. В контексте чат-ботов FSM помогает отслеживать, на каком этапе взаимодействия находится пользователь, и управлять последовательностью диалога.


---

### 1. Что такое FSM и зачем оно нужно в чат-ботах?

**FSM (Finite State Machine)** — это абстрактная машина, которая может находиться в одном из конечного числа состояний. Она может переходить из одного состояния в другое в ответ на внешние события (в нашем случае — на сообщения от пользователя).

**Зачем это нужно:**

- **Управление сложными диалогами**: FSM позволяет управлять многошаговыми диалогами, где бот должен запоминать информацию между шагами.
- **Контекстность**: С помощью FSM бот понимает, на каком этапе общения он находится, и реагирует соответствующим образом.
- **Организованность кода**: FSM помогает структурировать код и избегать запутанных условий и проверок.

---

### 2. Реализация FSM в `aiogram`

`aiogram` — это асинхронная библиотека для разработки Телеграм-ботов на Python. Она предоставляет встроенную поддержку FSM через модули `aiogram.fsm`.

**Основные компоненты FSM в `aiogram`:**

- **StatesGroup**: Класс, который объединяет набор состояний.
- **State**: Класс, представляющий конкретное состояние.
- **FSMContext**: Контекст, позволяющий хранить и получать данные, связанные с текущим состоянием пользователя.
- **Storage**: Механизм хранения состояний и данных (например, в памяти, в Redis и т.д.).

---

### 3. Определение состояний в боте

В коде определён класс `FinancesForm`, который наследуется от `StatesGroup`:

```python
class FinancesForm(StatesGroup):
    category = State()
    expenses = State()
    counter = State()
```

**Пояснения:**

- **FinancesForm**: Это группа состояний, связанных с процессом сбора данных о финансовых категориях и расходах пользователя.
- **category**: Состояние, в котором бот ожидает от пользователя ввод названия категории расхода.
- **expenses**: Состояние, в котором бот ожидает от пользователя ввод суммы расходов для указанной категории.
- **counter**: Переменная, используемая для отслеживания номера текущей категории (не является состоянием в традиционном понимании, так как в данном случае это просто данные, хранящиеся в контексте FSM).

---

### 4. Обработчики и переходы между состояниями

#### 4.1. Начало взаимодействия с FSM

Когда пользователь нажимает кнопку **"Личные финансы"**, срабатывает следующий обработчик:

```python
@dp.message(F.text == "Личные финансы")
async def finances_start(message: Message, state: FSMContext):
    await state.update_data(categories=[], expenses=[], counter=1)
    await state.set_state(FinancesForm.category)
    await message.reply("Введите название категории расхода №1:")
```

**Что здесь происходит:**

- **Инициализация данных**: В контексте FSM сохраняются пустые списки для категорий и расходов, а также устанавливается счётчик `counter = 1`.
- **Переход в состояние `FinancesForm.category`**: Бот устанавливает состояние, в котором он ожидает от пользователя ввод названия категории.
- **Отправка сообщения пользователю**: Бот просит ввести название первой категории расходов.

#### 4.2. Универсальный обработчик для состояний

Далее, универсальный обработчик обрабатывает сообщения в состояниях `FinancesForm.category` и `FinancesForm.expenses`:

```python
@dp.message(F.state.in_([FinancesForm.category, FinancesForm.expenses]))
async def finances_handler(message: Message, state: FSMContext):
    # Получение данных из контекста
    data = await state.get_data()
    counter = data.get('counter', 1)
    categories = data.get('categories', [])
    expenses = data.get('expenses', [])

    # Определение текущего состояния
    current_state = await state.get_state()
    if current_state == FinancesForm.category.state:
        # Обработка ввода категории
        categories.append(message.text)
        await state.update_data(categories=categories)
        await state.set_state(FinancesForm.expenses)
        await message.reply(f"Введите сумму расходов для категории '{message.text}':")
    elif current_state == FinancesForm.expenses.state:
        # Обработка ввода суммы расходов
        try:
            expense = float(message.text.replace(',', '.'))
            expenses.append(expense)
            await state.update_data(expenses=expenses)
            counter += 1
            await state.update_data(counter=counter)
            if counter <= 3:
                # Переход к следующей категории
                await state.set_state(FinancesForm.category)
                await message.reply(f"Введите название категории расхода №{counter}:")
            else:
                # Завершение сбора данных
                telegram_id = message.from_user.id
                categories_str = ';'.join(data['categories'])
                expenses_str = ';'.join(map(str, data['expenses']))
                async with aiosqlite.connect('user.db') as db:
                    await db.execute(
                        '''UPDATE users SET categories = ?, expenses = ? WHERE telegram_id = ?''',
                        (categories_str, expenses_str, telegram_id)
                    )
                    await db.commit()
                await state.clear()
                await message.answer("Категории и расходы сохранены!")
        except ValueError:
            await message.reply("Пожалуйста, введите числовое значение для расходов.")
```

**Разбор этого обработчика:**

- **Получение текущих данных**: Из FSMContext извлекаются текущие данные: `categories`, `expenses` и `counter`.
- **Определение текущего состояния**: С помощью `await state.get_state()` определяется, в каком состоянии находится бот.
- **Если состояние `FinancesForm.category`**:
  - Добавляем введённую пользователем категорию в список `categories`.
  - Обновляем данные в FSMContext.
  - Переходим в состояние `FinancesForm.expenses`.
  - Просим пользователя ввести сумму расходов для указанной категории.
- **Если состояние `FinancesForm.expenses`**:
  - Пробуем преобразовать введённый текст в число.
    - Если успешно:
      - Добавляем сумму расходов в список `expenses`.
      - Обновляем данные в FSMContext.
      - Увеличиваем счётчик категорий `counter`.
      - Проверяем, достигли ли мы нужного количества категорий (в данном случае 3).
        - Если ещё нет:
          - Переходим обратно в состояние `FinancesForm.category`.
          - Просим ввести название следующей категории.
        - Если да:
          - Сохраняем данные в базе данных.
          - Очищаем состояние FSM (`await state.clear()`), завершая диалог.
          - Сообщаем пользователю, что данные сохранены.
    - Если ошибка преобразования (введено нечисловое значение):
      - Просим пользователя ввести корректное числовое значение.

---

### 5. Как FSM управляет диалогом

**Пошаговый сценарий взаимодействия:**

1. **Пользователь выбирает "Личные финансы"**:
   - Бот устанавливает начальное состояние `FinancesForm.category`.
   - Инициализирует данные в FSMContext.
   - Просит ввести название первой категории.

2. **Пользователь вводит название категории**:
   - Бот принимает сообщение в состоянии `FinancesForm.category`.
   - Сохраняет название категории в список `categories`.
   - Переходит в состояние `FinancesForm.expenses`.
   - Просит ввести сумму расходов для этой категории.

3. **Пользователь вводит сумму расходов**:
   - Бот принимает сообщение в состоянии `FinancesForm.expenses`.
   - Пробует преобразовать ввод в число.
     - Если успешно:
       - Сохраняет сумму в список `expenses`.
       - Увеличивает счётчик `counter`.
       - Проверяет, нужно ли запрашивать ещё категории.
         - Если да (меньше или равно 3):
           - Переходит обратно в состояние `FinancesForm.category`.
           - Просит ввести название следующей категории.
         - Если нет:
           - Сохраняет все данные в базе данных.
           - Очищает состояние FSM.
           - Сообщает о завершении ввода.
     - Если неуспешно:
       - Просит ввести корректное числовое значение.

4. **Повторяет шаги 2 и 3 для следующих категорий**.

---

### 6. Хранение данных в FSMContext

**FSMContext** — это контекст состояния для каждого пользователя. Он позволяет хранить данные между сообщениями.

**Что хранится в FSMContext в вашем боте:**

- **categories**: Список названий категорий расходов, введённых пользователем.
- **expenses**: Список сумм расходов для каждой категории.
- **counter**: Номер текущей категории (от 1 до 3).

**Как данные обновляются:**

- **state.update_data(key=value)**: Добавляет или обновляет данные в контексте.
- **state.get_data()**: Получает все данные из контекста в виде словаря.

---

### 7. Завершение и сохранение данных

Когда пользователь вводит сумму расходов для третьей категории, бот:

- Собирает все данные из FSMContext.
- Преобразует списки категорий и расходов в строки, соединяя элементы через `;`.
- Сохраняет эти строки в базе данных в соответствующих полях.
- Очищает состояние FSM (`await state.clear()`), что означает завершение диалога и сброс состояния пользователя.
- Сообщает пользователю, что данные сохранены.

---

### 8. Почему используется один универсальный обработчик

Использование одного обработчика для нескольких состояний упрощает код и делает его более масштабируемым.

**Преимущества:**

- **Сокращение кода**: Вместо написания отдельного обработчика для каждого состояния, вы используете один с логикой, зависящей от текущего состояния.
- **Легкость поддержки**: Изменения в логике вводятся в одном месте.
- **Масштабируемость**: Легче добавить новые состояния или изменить существующие.

---

### 9. Важные моменты и лучшие практики

- **Обработка ошибок**: При преобразовании пользовательского ввода в число используется блок `try-except` для обработки возможных ошибок и информирования пользователя о некорректном вводе.
- **Очистка состояния**: После завершения диалога состояние FSM очищается, чтобы пользователь мог начать новый диалог с нуля.
- **Хранение данных между сообщениями**: FSMContext позволяет хранить данные между сообщениями без необходимости использования глобальных переменных или базы данных на этом этапе.

---
